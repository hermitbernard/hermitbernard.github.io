<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Pong Game - AI vs AI</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #score {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            pointer-events: none;
            z-index: 100;
        }
        #audioToggle {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(80px);
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            z-index: 101;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        #audioToggle:hover {
            opacity: 1;
        }
        #audioToggle.muted::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 100%;
            background: red;
            transform: rotate(45deg);
            left: 50%;
            top: 0;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 1rem;
            pointer-events: none;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 0;
        }
        #cameraControls {
            position: absolute;
            top: 60px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 100;
        }
        #winMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2rem;
            text-align: center;
            display: none;
            z-index: 200;
        }
        #winMessage button {
            background: linear-gradient(145deg, #5d5d5d, #4e4e4e);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 15px 32px;
            width: 180px;
            height: 60px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            font-weight: bold;
            margin: 20px 0 10px;
            cursor: pointer;
            transform-style: preserve-3d;
            position: relative;
            transform: translateZ(10px);
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4), 
                        0 6px 6px rgba(0,0,0,0.3),
                        0 0 0 2px rgba(255,255,255,0.2);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        #winMessage button:hover {
            background: linear-gradient(145deg, #666666, #555555);
            transform: translateZ(5px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4), 
                       0 3px 3px rgba(0,0,0,0.3),
                       0 0 0 2px rgba(255,255,255,0.3);
        }

        #winMessage button:active {
            transform: translateZ(2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.4), 
                       0 1px 2px rgba(0,0,0,0.3),
                       0 0 0 2px rgba(255,255,255,0.4);
        }
        
        /* Improved mobile styles */
        @media (max-width: 767px) {
            #score {
                top: 10px;
                font-size: 2rem;
            }
            
            @media (orientation: landscape) {
                #score {
                    top: -10px;
                    font-size: 1.8rem;
                    text-shadow: 0 0 10px rgba(0, 0, 0, 0.9);
                    z-index: 150;
                }
            }
        }
    </style>
</head>
<body>
    <div id="score">0 - 0</div>
    <button id="audioToggle" title="Toggle sound">üîä</button>
    <div id="instructions">AI vs AI Mode | Press SPACE to take control | ‚Üë ‚Üì ‚Üê ‚Üí Arrow keys or mouse to move</div>
    <div id="winMessage">
        <p id="winText"></p>
        <button id="playAgain">PLAY AGAIN</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Constants
        const FIELD_WIDTH = 800;
        const FIELD_HEIGHT = 500;
        const FIELD_DEPTH = 20;
        const BALL_SIZE = 20;
        const PADDLE_WIDTH = 20;
        const PADDLE_HEIGHT = 80;
        const PADDLE_DEPTH = 20;
        const BOUNDARY_THICKNESS = 20;
        const INITIAL_BALL_SPEED_X = 5;
        const INITIAL_BALL_SPEED_Y = 5;
        const BALL_SPEED_INCREMENT = 0.2;
        const PADDLE_SPEED = 7; 
        const FLASH_DURATION = 10;
        const WINNING_SCORE = 5;
        const KEYBOARD_PADDLE_SPEED = 10;
        
        // AI difficulty (0.0 to 1.0) - Higher means better AI
        // 0.0 = Very bad AI (will miss most balls)
        // 0.5 = Decent AI (will miss sometimes)
        // 1.0 = Perfect AI (will rarely miss)
        const AI_DIFFICULTY = 0.7;

        // Game state variables
        let ballColor, paddleColor, boundaryColor;
        let ball_speed_x = INITIAL_BALL_SPEED_X;
        let ball_speed_y = INITIAL_BALL_SPEED_Y;
        let score_left = 0, score_right = 0;
        let flash_counter_left = 0, flash_counter_right = 0;
        let offset1 = 0, offset2 = 0;
        let errorAccumulation1 = 0; // Error accumulation for left paddle
        let errorAccumulation2 = 0; // Error accumulation for right paddle
        let frameCount = 0;
        let gameActive = true;
        let lastTimestamp = 0;
        let isMobile = window.innerWidth < 768;
        let playerControlled = false; // Both paddles AI-controlled by default
        let lastBounceTime = 0; // To prevent multiple bounces in a short time
        let audioEnabled = false; // Audio disabled by default
        
        // Add smoothing variables for paddle movement
        let smoothedErrorOffset1 = 0;
        let smoothedErrorOffset2 = 0;
        let targetPaddle1Y = 0;
        let targetPaddle2Y = 0;
        let currentTargetP1 = 0;
        let currentTargetP2 = 0;
        
        // Keyboard control
        let keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false,
            KeyQ: false,
            KeyE: false,
            KeyZ: false,
            KeyX: false
        };
        
        // Camera control
        let cameraRotation = {
            x: 0,
            y: 0,
            z: 0  // Roll rotation around camera's own x-axis
        };
        
        let cameraDistance = 600;
        let defaultCameraPosition = { x: 0, y: 0, z: 600 };
        let cameraMode = "orbit"; // "orbit", "parallel", "leftPaddle", "rightPaddle"
        let paddleViewOffset = 100; // Distance behind the paddle for paddle view
        let paddleViewHeight = 50;  // Height offset for better visibility

        // Three.js objects
        let scene, camera, renderer;
        let ball, paddle1, paddle2, topBoundary, bottomBoundary, gameField;
        let particles = [];
        let lights = [];
        
        // DOM elements
        const scoreElement = document.getElementById('score');
        const instructionsElement = document.getElementById('instructions');
        const winMessageElement = document.getElementById('winMessage');
        const winTextElement = document.getElementById('winText');
        const playAgainButton = document.getElementById('playAgain');
        const audioToggle = document.getElementById('audioToggle');

        // Initialize Three.js scene
        function initScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);
            
            // Setup audio toggle
            audioToggle.addEventListener('click', () => {
                audioEnabled = !audioEnabled;
                audioToggle.classList.toggle('muted', !audioEnabled);
                audioToggle.textContent = audioEnabled ? 'üîä' : 'üîà';
                
                // Try to initialize audio context when enabled
                if (audioEnabled) {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        // Play a silent sound to unlock audio on mobile
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.001);
                    } catch (e) {
                        console.log("Audio initialization failed", e);
                    }
                }
            });
            
            // Create camera (use perspective for 3D effect)
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 2000);
            camera.position.set(0, 0, isMobile ? 700 : 600);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Initial responsive adjustments based on device
            if (isMobile) {
                if (window.innerHeight > window.innerWidth) {
                    // Portrait orientation initial setup
                    camera.position.z = 1000;
                }
            }
            
            createLights();
            createGameElements();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            if (isMobile) {
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchstart', function(event) {
                    togglePlayerControl();
                });
                updateInstructions();
            } else {
                document.addEventListener('mousemove', onMouseMove);
            }
            
            playAgainButton.addEventListener('click', resetGame);
            
            // Call updateCameraPosition once at initialization
            updateCameraPosition();
        }
        
        function createLights() {
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(0, 200, 400);
            mainLight.castShadow = true;
            mainLight.shadow.camera.near = 0.1;
            mainLight.shadow.camera.far = 1000;
            mainLight.shadow.camera.left = -FIELD_WIDTH;
            mainLight.shadow.camera.right = FIELD_WIDTH;
            mainLight.shadow.camera.top = FIELD_HEIGHT;
            mainLight.shadow.camera.bottom = -FIELD_HEIGHT;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            // Spotlight to focus on the ball
            const ballSpotlight = new THREE.SpotLight(0xffffff, 1);
            ballSpotlight.position.set(0, 200, 200);
            ballSpotlight.angle = Math.PI / 6;
            ballSpotlight.penumbra = 0.5;
            ballSpotlight.castShadow = true;
            scene.add(ballSpotlight);
            lights.push(ballSpotlight);
            
            // Add side lights for dramatic effect
            const leftLight = new THREE.PointLight(0xff4444, 0.5);
            leftLight.position.set(-FIELD_WIDTH/2 - 100, 0, 100);
            scene.add(leftLight);
            
            const rightLight = new THREE.PointLight(0x4444ff, 0.5);
            rightLight.position.set(FIELD_WIDTH/2 + 100, 0, 100);
            scene.add(rightLight);
        }
        
        function getRandomColor() {
            return new THREE.Color(
                Math.random(),
                Math.random(),
                Math.random()
            );
        }
        
        function createGameElements() {
            // Initialize random colors
            ballColor = getRandomColor();
            paddleColor = getRandomColor();
            boundaryColor = getRandomColor();
            
            // Create game field
            const fieldGeometry = new THREE.BoxGeometry(FIELD_WIDTH, FIELD_HEIGHT, FIELD_DEPTH);
            const fieldMaterial = new THREE.MeshPhongMaterial({
                color: 0x003300,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            gameField = new THREE.Mesh(fieldGeometry, fieldMaterial);
            gameField.receiveShadow = true;
            gameField.position.z = -FIELD_DEPTH/2;
            scene.add(gameField);
            
            // Create boundaries
            const boundaryMaterial = new THREE.MeshPhongMaterial({
                color: boundaryColor,
                specular: 0x222222,
                shininess: 100
            });
            
            // Top boundary
            const topGeometry = new THREE.BoxGeometry(FIELD_WIDTH, BOUNDARY_THICKNESS, FIELD_DEPTH * 2);
            topBoundary = new THREE.Mesh(topGeometry, boundaryMaterial);
            topBoundary.position.y = FIELD_HEIGHT/2 + BOUNDARY_THICKNESS/2;
            topBoundary.castShadow = true;
            topBoundary.receiveShadow = true;
            scene.add(topBoundary);
            
            // Bottom boundary
            const bottomGeometry = new THREE.BoxGeometry(FIELD_WIDTH, BOUNDARY_THICKNESS, FIELD_DEPTH * 2);
            bottomBoundary = new THREE.Mesh(bottomGeometry, boundaryMaterial);
            bottomBoundary.position.y = -FIELD_HEIGHT/2 - BOUNDARY_THICKNESS/2;
            bottomBoundary.castShadow = true;
            bottomBoundary.receiveShadow = true;
            scene.add(bottomBoundary);
            
            // Create paddles
            const paddleMaterial = new THREE.MeshPhongMaterial({
                color: paddleColor,
                specular: 0xffffff,
                shininess: 100
            });
            
            // Left paddle
            const paddle1Geometry = new THREE.BoxGeometry(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH);
            paddle1 = new THREE.Mesh(paddle1Geometry, paddleMaterial.clone());
            paddle1.position.x = -FIELD_WIDTH/2 + PADDLE_WIDTH/2;
            paddle1.castShadow = true;
            paddle1.receiveShadow = true;
            scene.add(paddle1);
            
            // Right paddle
            const paddle2Geometry = new THREE.BoxGeometry(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH);
            paddle2 = new THREE.Mesh(paddle2Geometry, paddleMaterial.clone());
            paddle2.position.x = FIELD_WIDTH/2 - PADDLE_WIDTH/2;
            paddle2.castShadow = true;
            paddle2.receiveShadow = true;
            scene.add(paddle2);
            
            // Create ball
            const ballGeometry = new THREE.SphereGeometry(BALL_SIZE/2, 32, 32);
            const ballMaterial = new THREE.MeshPhongMaterial({
                color: ballColor,
                specular: 0xffffff,
                shininess: 100,
                emissive: ballColor,
                emissiveIntensity: 0.5
            });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.castShadow = true;
            ball.receiveShadow = true;
            scene.add(ball);
            
            // Center line
            const centerLineGeometry = new THREE.BoxGeometry(2, FIELD_HEIGHT, FIELD_DEPTH/2);
            const centerLineMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
            centerLine.position.z = 1;
            scene.add(centerLine);
            
            // Initial scaling for mobile
            if (isMobile && window.innerHeight > window.innerWidth) {
                gameField.scale.set(0.7, 0.7, 0.7);
                paddle1.scale.set(1.5, 1.5, 1.5);
                paddle2.scale.set(1.5, 1.5, 1.5);
                ball.scale.set(1.5, 1.5, 1.5);
            }
            
            resetBall();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            isMobile = window.innerWidth < 768;
            
            // Adjust camera based on device and orientation
            if (isMobile) {
                if (window.innerHeight > window.innerWidth) {
                    // Portrait mode
                    cameraDistance = 1000;
                    // Scale down the game field for portrait mode
                    gameField.scale.set(0.7, 0.7, 0.7);
                    paddle1.scale.set(1.5, 1.5, 1.5);
                    paddle2.scale.set(1.5, 1.5, 1.5);
                    ball.scale.set(1.5, 1.5, 1.5);
                } else {
                    // Landscape mode
                    cameraDistance = 600;
                    gameField.scale.set(0.9, 0.9, 0.9);
                    paddle1.scale.set(1, 1, 1);
                    paddle2.scale.set(1, 1, 1);
                    ball.scale.set(1, 1, 1);
                }
            } else {
                cameraDistance = 600;
                gameField.scale.set(1, 1, 1);
                paddle1.scale.set(1, 1, 1);
                paddle2.scale.set(1, 1, 1);
                ball.scale.set(1, 1, 1);
            }
            
            updateCameraPosition();
            updateInstructions();
        }
        
        function onKeyDown(event) {
            if (event.code === 'Space') {
                togglePlayerControl();
            }
            if (event.code === 'ArrowUp' || event.code === 'ArrowDown' || event.code === 'ArrowLeft' || event.code === 'ArrowRight') {
                keys[event.code] = true;
                
                // If not already player controlled, switch to player control
                if (!playerControlled) {
                    togglePlayerControl();
                }
            }
            
            // Camera controls
            if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyZ', 'KeyX'].includes(event.code)) {
                keys[event.code] = true;
            }
            
            // Reset camera position with R key
            if (event.code === 'KeyR') {
                resetCameraPosition();
            }
            
            // Camera mode switching
            if (event.code === 'Digit1') {
                cameraMode = "orbit";
                cameraRotation.x = 0;
                cameraRotation.y = 0;
                cameraRotation.z = 0;
                updateCameraPosition();
            } else if (event.code === 'Digit2') {
                cameraMode = "parallel";
                cameraRotation.x = 0;
                cameraRotation.y = 0;
                cameraRotation.z = 0;
                updateCameraPosition();
            } else if (event.code === 'Digit3') {
                cameraMode = "leftPaddle";
                cameraRotation.x = Math.PI/2 - 0.1; // Max S press
                cameraRotation.z = -Math.PI/2;      // 90 degrees roll (as if pressing X)
                updateCameraPosition();
            } else if (event.code === 'Digit4') {
                cameraMode = "rightPaddle";
                cameraRotation.x = Math.PI/2 - 0.1; // Max S press
                cameraRotation.y = -Math.PI/2;       // 90 degrees Y rotation
                updateCameraPosition();
            }
        }
        
        function onKeyUp(event) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyZ', 'KeyX'].includes(event.code)) {
                keys[event.code] = false;
            }
        }
        
        function resetCameraPosition() {
            cameraRotation.x = 0;
            cameraRotation.y = 0;
            cameraRotation.z = 0; // Reset roll rotation
            cameraDistance = isMobile && window.innerHeight > window.innerWidth ? 1000 : 600;
            updateCameraPosition();
        }
        
        function updateCameraPosition() {
            // Reset camera orientation first
            camera.up.set(0, 1, 0);
            
            switch (cameraMode) {
                case "leftPaddle":
                    // Position camera behind left paddle with better visibility
                    camera.position.x = paddle1.position.x - paddleViewOffset;
                    camera.position.y = paddle1.position.y + paddleViewHeight;
                    camera.position.z = 100; // Offset in Z axis for better perspective
                    
                    // Look at a point slightly in front of the paddle toward the field center
                    camera.lookAt(
                        paddle1.position.x + 100, // Look ahead of the paddle
                        paddle1.position.y, 
                        0
                    );
                    
                    // Apply roll rotation around camera's local Z axis
                    if (cameraRotation.z !== 0) {
                        camera.rotateZ(cameraRotation.z);
                    }
                    break;
                    
                case "rightPaddle":
                    // Position camera behind right paddle with better visibility
                    camera.position.x = paddle2.position.x + paddleViewOffset;
                    camera.position.y = paddle2.position.y + paddleViewHeight;
                    camera.position.z = 100; // Offset in Z axis for better perspective
                    
                    // Look at a point slightly in front of the paddle toward the field center
                    camera.lookAt(
                        paddle2.position.x - 100, // Look ahead of the paddle 
                        paddle2.position.y, 
                        0
                    );
                    
                    // Apply roll rotation around camera's local Z axis
                    if (cameraRotation.z !== 0) {
                        camera.rotateZ(cameraRotation.z);
                    }
                    break;
                    
                case "parallel":
                    // Calculate distance based on device
                    const distanceParallel = isMobile && window.innerHeight > window.innerWidth ? 1000 : cameraDistance;
                    
                    // Calculate position using spherical coordinates
                    camera.position.x = distanceParallel * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
                    camera.position.z = distanceParallel * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
                    camera.position.y = distanceParallel * Math.sin(cameraRotation.x);
                    
                    // Create a direction vector pointing along global Z-axis
                    const direction = new THREE.Vector3(0, 0, -1);
                    
                    // Rotate the direction vector based on our horizontal rotation (y)
                    direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotation.y);
                    
                    // Calculate lookAt point by extending the direction from camera position
                    const lookAtPoint = new THREE.Vector3();
                    lookAtPoint.copy(camera.position).add(direction.multiplyScalar(100));
                    
                    // Point camera at this point
                    camera.lookAt(lookAtPoint);
                    
                    // Now apply vertical rotation (x) by rotating around local X axis
                    camera.rotateX(cameraRotation.x);
                    
                    // Apply roll rotation around camera's local Z axis
                    if (cameraRotation.z !== 0) {
                        camera.rotateZ(cameraRotation.z);
                    }
                    break;
                    
                case "orbit":
                default:
                    // Calculate distance based on device
                    const distance = isMobile && window.innerHeight > window.innerWidth ? 1000 : cameraDistance;
                    
                    // Calculate position using spherical coordinates
                    camera.position.x = distance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
                    camera.position.z = distance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
                    camera.position.y = distance * Math.sin(cameraRotation.x);
                    
                    // Original orbit camera mode - always look at center
                    camera.lookAt(0, 0, 0);
                    
                    // Apply roll rotation around camera's local Z axis
                    if (cameraRotation.z !== 0) {
                        camera.rotateZ(cameraRotation.z);
                    }
                    break;
            }
        }
        
        function updateCamera(deltaTime) {
            const rotationSpeed = 0.03 * deltaTime;
            const zoomSpeed = 10 * deltaTime;
            let changed = false;
            
            // Roll rotation (Z/X) - available in all camera modes
            if (keys.KeyZ) {
                cameraRotation.z += rotationSpeed;
                changed = true;
            }
            if (keys.KeyX) {
                cameraRotation.z -= rotationSpeed;
                changed = true;
            }
            
            // Limit roll rotation to prevent disorientation
            cameraRotation.z = Math.max(-Math.PI, Math.min(Math.PI, cameraRotation.z));
            
            // Only apply these controls for orbit and parallel modes
            if (cameraMode === "orbit" || cameraMode === "parallel") {
                // Vertical rotation (W/S)
                if (keys.KeyW) {
                    if (cameraMode === "parallel") {
                        // In parallel view, W/S control pitch (rotation around local X axis)
                        cameraRotation.x -= rotationSpeed; // Inverted for intuitive control
                    } else {
                        cameraRotation.x += rotationSpeed;
                    }
                    changed = true;
                }
                if (keys.KeyS) {
                    if (cameraMode === "parallel") {
                        cameraRotation.x += rotationSpeed; // Inverted for intuitive control
                    } else {
                        cameraRotation.x -= rotationSpeed;
                    }
                    changed = true;
                }
                
                // Horizontal rotation (A/D)
                if (keys.KeyA) {
                    cameraRotation.y += rotationSpeed;
                    changed = true;
                }
                if (keys.KeyD) {
                    cameraRotation.y -= rotationSpeed;
                    changed = true;
                }
                
                // Zoom in/out (Q/E)
                if (keys.KeyQ) {
                    cameraDistance -= zoomSpeed;
                    changed = true;
                }
                if (keys.KeyE) {
                    cameraDistance += zoomSpeed;
                    changed = true;
                }
                
                // Limit the vertical rotation 
                if (cameraMode === "parallel") {
                    // In parallel view, limit pitch to avoid flipping
                    cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                } else {
                    // In orbit view, limit elevation angle
                    cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                }
                
                // Limit zoom range
                cameraDistance = Math.max(100, Math.min(1200, cameraDistance));
            } else if (cameraMode === "leftPaddle" || cameraMode === "rightPaddle") {
                // Additional controls for paddle view
                
                // Allow fine-tuning of height with W/S keys 
                if (keys.KeyW) {
                    paddleViewHeight += 2 * deltaTime;
                    changed = true;
                }
                if (keys.KeyS) {
                    paddleViewHeight -= 2 * deltaTime;
                    changed = true;
                }
                
                // Allow fine-tuning of distance with Q/E keys
                if (keys.KeyQ) {
                    paddleViewOffset -= 2 * deltaTime;
                    changed = true;
                }
                if (keys.KeyE) {
                    paddleViewOffset += 2 * deltaTime;
                    changed = true;
                }
                
                // Limit height and offset to reasonable values
                paddleViewHeight = Math.max(0, Math.min(200, paddleViewHeight));
                paddleViewOffset = Math.max(50, Math.min(200, paddleViewOffset));
            }
            
            // For paddle views, we always need to update camera position to follow the paddle
            if (cameraMode === "leftPaddle" || cameraMode === "rightPaddle") {
                changed = true;
            }
            
            if (changed) {
                updateCameraPosition();
            }
        }
        
        function togglePlayerControl() {
            playerControlled = !playerControlled;
            updateInstructions();
        }
        
        function updateInstructions() {
            let controlText = "";
            
            if (playerControlled) {
                if (isMobile) {
                    controlText = "Player vs AI Mode | Touch and drag to move your paddle";
                } else {
                    controlText = "Player vs AI Mode | ‚Üë ‚Üì ‚Üê ‚Üí Arrow keys or mouse to move";
                }
            } else {
                if (isMobile) {
                    controlText = "AI vs AI Mode | Tap screen to take control";
                } else {
                    controlText = "AI vs AI Mode | Press SPACE to take control | ‚Üë ‚Üì ‚Üê ‚Üí Arrow keys or mouse to move";
                }
            }
            
            controlText += " | Camera modes: 1-Orbit, 2-Parallel, 3-Left Paddle, 4-Right Paddle | Z/X for camera roll";
            instructionsElement.textContent = controlText;
        }
        
        function onMouseMove(event) {
            if (!playerControlled) return;
            
            const mouseY = (event.clientY / window.innerHeight) * 2 - 1;
            paddle1.position.y = -mouseY * (FIELD_HEIGHT/2 - PADDLE_HEIGHT/2);
            
            // Keep paddle within bounds
            if (paddle1.position.y > FIELD_HEIGHT/2 - PADDLE_HEIGHT/2) {
                paddle1.position.y = FIELD_HEIGHT/2 - PADDLE_HEIGHT/2;
            } else if (paddle1.position.y < -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2) {
                paddle1.position.y = -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2;
            }
        }
        
        function onTouchMove(event) {
            if (!playerControlled) return;
            
            event.preventDefault();
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                const touchY = (touch.clientY / window.innerHeight) * 2 - 1;
                paddle1.position.y = -touchY * (FIELD_HEIGHT/2 - PADDLE_HEIGHT/2);
                
                // Keep paddle within bounds
                if (paddle1.position.y > FIELD_HEIGHT/2 - PADDLE_HEIGHT/2) {
                    paddle1.position.y = FIELD_HEIGHT/2 - PADDLE_HEIGHT/2;
                } else if (paddle1.position.y < -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2) {
                    paddle1.position.y = -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2;
                }
            }
        }
        
        function updateGame(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 16.67; // Normalize to ~60fps
            lastTimestamp = timestamp;
            
            // Update camera based on key presses
            updateCamera(deltaTime);
            
            if (!gameActive) {
                renderer.render(scene, camera);
                requestAnimationFrame(updateGame);
                return;
            }
            
            // Keyboard paddle control
            if (playerControlled) {
                if (keys.ArrowUp || keys.ArrowLeft) {
                    paddle1.position.y += KEYBOARD_PADDLE_SPEED * deltaTime;
                }
                if (keys.ArrowDown || keys.ArrowRight) {
                    paddle1.position.y -= KEYBOARD_PADDLE_SPEED * deltaTime;
                }
                
                // Keep paddle within bounds
                if (paddle1.position.y > FIELD_HEIGHT/2 - PADDLE_HEIGHT/2) {
                    paddle1.position.y = FIELD_HEIGHT/2 - PADDLE_HEIGHT/2;
                } else if (paddle1.position.y < -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2) {
                    paddle1.position.y = -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2;
                }
            }
            
            // Store previous position for collision detection
            const prevY = ball.position.y;
            
            // Update ball position
            ball.position.x += ball_speed_x * deltaTime;
            ball.position.y += ball_speed_y * deltaTime;
            
            // Ball rotation for added effect
            ball.rotation.x += 0.02 * deltaTime;
            ball.rotation.z += 0.03 * deltaTime;
            
            // Update spotlight to follow ball
            if (lights[0]) {
                lights[0].position.x = ball.position.x;
                lights[0].position.y = ball.position.y + 100;
                lights[0].target = ball;
            }
            
            // Improved ball collision with top/bottom boundaries
            // Using the ball's position and the boundaries' positions
            const topBoundaryBottom = FIELD_HEIGHT/2;
            const bottomBoundaryTop = -FIELD_HEIGHT/2;
            
            // Check if the ball is moving towards the boundary before applying bounce
            if ((ball.position.y + BALL_SIZE/2 >= topBoundaryBottom && ball_speed_y > 0) ||
                (ball.position.y - BALL_SIZE/2 <= bottomBoundaryTop && ball_speed_y < 0)) {
                
                // Prevent double bouncing in the same frame
                const currentTime = timestamp;
                if (currentTime - lastBounceTime > 50) { // 50ms debounce time
                    ball_speed_y *= -1;
                    createParticleExplosion(ball.position.x, ball.position.y, 0, 10);
                    playSound(220, 0.1);
                    lastBounceTime = currentTime;
                    
                    // Make sure ball is not stuck in the boundary
                    if (ball.position.y + BALL_SIZE/2 > topBoundaryBottom) {
                        ball.position.y = topBoundaryBottom - BALL_SIZE/2;
                    } else if (ball.position.y - BALL_SIZE/2 < bottomBoundaryTop) {
                        ball.position.y = bottomBoundaryTop + BALL_SIZE/2;
                    }
                }
            }
            
            // Ball collision with paddles
            if (ball.position.x - BALL_SIZE/2 <= -FIELD_WIDTH/2 + PADDLE_WIDTH &&
                ball.position.y >= paddle1.position.y - PADDLE_HEIGHT/2 &&
                ball.position.y <= paddle1.position.y + PADDLE_HEIGHT/2 &&
                ball_speed_x < 0) { // Only bounce if moving towards the paddle
                
                ball_speed_x = Math.abs(ball_speed_x) + BALL_SPEED_INCREMENT;
                createParticleExplosion(ball.position.x, ball.position.y, 0, 20);
                flash_counter_left = FLASH_DURATION;
                
                // Play sound
                playSound(330, 0.2);
                
                // Adjust ball direction based on where it hit the paddle
                const hitPosition = (ball.position.y - paddle1.position.y) / (PADDLE_HEIGHT/2);
                ball_speed_y = hitPosition * 10;
                
                // Make sure ball is not stuck in the paddle
                ball.position.x = -FIELD_WIDTH/2 + PADDLE_WIDTH + BALL_SIZE/2;
                
            } else if (ball.position.x + BALL_SIZE/2 >= FIELD_WIDTH/2 - PADDLE_WIDTH &&
                      ball.position.y >= paddle2.position.y - PADDLE_HEIGHT/2 &&
                      ball.position.y <= paddle2.position.y + PADDLE_HEIGHT/2 &&
                      ball_speed_x > 0) { // Only bounce if moving towards the paddle
                
                ball_speed_x = -Math.abs(ball_speed_x) - BALL_SPEED_INCREMENT;
                createParticleExplosion(ball.position.x, ball.position.y, 0, 20);
                flash_counter_right = FLASH_DURATION;
                
                // Play sound
                playSound(440, 0.2);
                
                // Adjust ball direction based on where it hit the paddle
                const hitPosition = (ball.position.y - paddle2.position.y) / (PADDLE_HEIGHT/2);
                ball_speed_y = hitPosition * 10;
                
                // Make sure ball is not stuck in the paddle
                ball.position.x = FIELD_WIDTH/2 - PADDLE_WIDTH - BALL_SIZE/2;
            }
            
            // Update AI paddles
            updateAIPaddles(deltaTime);
            
            // Update randomness every 30 frames
            if (frameCount % 30 === 0) {
                // Scale random offset range by inverse of AI difficulty
                const offsetRange = 30 * (2 - AI_DIFFICULTY);
                offset1 = Math.random() * offsetRange - (offsetRange/2);
                offset2 = Math.random() * offsetRange - (offsetRange/2);
                
                // Gradually increase error accumulation over time, scaled by inverse of AI difficulty
                const errorIncrease = 0.3 * (2 - AI_DIFFICULTY);
                errorAccumulation1 += Math.random() * errorIncrease;
                errorAccumulation2 += Math.random() * errorIncrease;
                
                // Cap error accumulation based on AI difficulty
                const maxError = 20 * (2 - AI_DIFFICULTY);
                errorAccumulation1 = Math.min(errorAccumulation1, maxError);
                errorAccumulation2 = Math.min(errorAccumulation2, maxError);
            }
            frameCount++;
            
            // Check scores and reset if needed
            if (ball.position.x < -FIELD_WIDTH/2 - BALL_SIZE) {
                // Right player scores
                score_right++;
                scoreElement.textContent = `${score_left} - ${score_right}`;
                createParticleExplosion(ball.position.x, ball.position.y, 0, 50);
                playSound(175, 0.3);
                
                if (score_right >= WINNING_SCORE) {
                    if (playerControlled) {
                        endGame("AI Wins!");
                    } else {
                        // In AI vs AI mode, just restart the game
                        flashScreen();
                        resetGame();
                    }
                } else {
                    flashScreen();
                    resetBall();
                }
            } else if (ball.position.x > FIELD_WIDTH/2 + BALL_SIZE) {
                // Left player scores
                score_left++;
                scoreElement.textContent = `${score_left} - ${score_right}`;
                createParticleExplosion(ball.position.x, ball.position.y, 0, 50);
                playSound(146.83, 0.3);
                
                if (score_left >= WINNING_SCORE) {
                    if (playerControlled) {
                        endGame("You Win!");
                    } else {
                        // In AI vs AI mode, just restart the game
                        flashScreen();
                        resetGame();
                    }
                } else {
                    flashScreen();
                    resetBall();
                }
            }
            
            // Update flash counters
            if (flash_counter_left > 0) {
                flash_counter_left--;
                paddle1.material.color.setRGB(1, 0, 0);
            } else {
                paddle1.material.color.copy(paddleColor);
            }
            
            if (flash_counter_right > 0) {
                flash_counter_right--;
                paddle2.material.color.setRGB(1, 0, 0);
            } else {
                paddle2.material.color.copy(paddleColor);
            }
            
            // Update particles
            updateParticles(deltaTime);
            
            renderer.render(scene, camera);
            requestAnimationFrame(updateGame);
        }
        
        function updateAIPaddles(deltaTime) {
            // Left paddle AI (only if not player controlled)
            if (!playerControlled && ball_speed_x < 0) {
                // Base target position (where the ball is)
                const baseTargetY = ball.position.y;
                
                // Add a simple prediction based on ball velocity and AI difficulty
                const predictionFactor = 8 * AI_DIFFICULTY; // Reduce prediction accuracy for lower difficulty
                const predictedY = baseTargetY + (ball_speed_y * predictionFactor);
                
                // Calculate error with smoother sin wave (slower frequency)
                // Reduce the error impact as ball gets closer to make AI more accurate when it matters
                const distanceFromPaddle = Math.abs(ball.position.x - paddle1.position.x);
                const errorFactor = Math.min(1, distanceFromPaddle / (FIELD_WIDTH * 0.4)) * (2 - AI_DIFFICULTY);
                const errorOffset = Math.sin(frameCount * 0.005) * errorAccumulation1 * errorFactor;
                
                // Smooth the error offset over time
                const errorSmoothingFactor = 0.1 * AI_DIFFICULTY;
                smoothedErrorOffset1 = lerp(smoothedErrorOffset1, errorOffset, errorSmoothingFactor * deltaTime);
                
                // Current target is base position + static offset + smoothed dynamic error
                currentTargetP1 = predictedY + offset1 * errorFactor + smoothedErrorOffset1;
                
                // Smooth the paddle movement target, faster response when ball is closer
                const baseLerpFactor = 0.1 * AI_DIFFICULTY;
                const maxLerpFactor = 0.3 * AI_DIFFICULTY;
                const lerpFactor = Math.min(maxLerpFactor, baseLerpFactor + (1 - distanceFromPaddle / FIELD_WIDTH) * 0.4);
                targetPaddle1Y = lerp(targetPaddle1Y, currentTargetP1, lerpFactor * deltaTime);
                
                moveAIPaddle(paddle1, targetPaddle1Y, deltaTime);
            }
            
            // Right paddle AI
            if (ball_speed_x > 0) {
                // Base target position (where the ball is)
                const baseTargetY = ball.position.y;
                
                // Add a simple prediction based on ball velocity and AI difficulty
                const predictionFactor = 8 * AI_DIFFICULTY; // Reduce prediction accuracy for lower difficulty
                const predictedY = baseTargetY + (ball_speed_y * predictionFactor);
                
                // Calculate error with smoother sin wave (slower frequency)
                // Reduce the error impact as ball gets closer to make AI more accurate when it matters
                const distanceFromPaddle = Math.abs(ball.position.x - paddle2.position.x);
                const errorFactor = Math.min(1, distanceFromPaddle / (FIELD_WIDTH * 0.4)) * (2 - AI_DIFFICULTY);
                const errorOffset = Math.sin(frameCount * 0.005) * errorAccumulation2 * errorFactor;
                
                // Smooth the error offset over time
                const errorSmoothingFactor = 0.1 * AI_DIFFICULTY;
                smoothedErrorOffset2 = lerp(smoothedErrorOffset2, errorOffset, errorSmoothingFactor * deltaTime);
                
                // Current target is base position + static offset + smoothed dynamic error
                currentTargetP2 = predictedY + offset2 * errorFactor + smoothedErrorOffset2;
                
                // Smooth the paddle movement target, faster response when ball is closer
                const baseLerpFactor = 0.1 * AI_DIFFICULTY;
                const maxLerpFactor = 0.3 * AI_DIFFICULTY;
                const lerpFactor = Math.min(maxLerpFactor, baseLerpFactor + (1 - distanceFromPaddle / FIELD_WIDTH) * 0.4);
                targetPaddle2Y = lerp(targetPaddle2Y, currentTargetP2, lerpFactor * deltaTime);
                
                moveAIPaddle(paddle2, targetPaddle2Y, deltaTime);
            }
        }
        
        // Linear interpolation helper function
        function lerp(start, end, amount) {
            return start + (end - start) * amount;
        }
        
        function moveAIPaddle(paddle, targetY, deltaTime) {
            // Calculate distance to target
            const distance = targetY - paddle.position.y;
            
            // Apply smooth movement with variable speed based on distance and AI difficulty
            // Faster when far, slower when close, but with higher base speed
            const maxSpeedFactor = 1.5 * AI_DIFFICULTY;
            const speedFactor = Math.min(maxSpeedFactor, Math.abs(distance) / (30 / AI_DIFFICULTY));
            const moveAmount = PADDLE_SPEED * speedFactor * deltaTime;
            
            // Move toward target with dampening as we get closer
            if (Math.abs(distance) > 0.5) {
                paddle.position.y += Math.sign(distance) * moveAmount;
            }
            
            // Keep paddle within bounds
            if (paddle.position.y > FIELD_HEIGHT/2 - PADDLE_HEIGHT/2) {
                paddle.position.y = FIELD_HEIGHT/2 - PADDLE_HEIGHT/2;
            } else if (paddle.position.y < -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2) {
                paddle.position.y = -FIELD_HEIGHT/2 + PADDLE_HEIGHT/2;
            }
        }
        
        function resetBall() {
            ball.position.set(0, 0, 0);
            
            // Choose random direction
            const directionX = Math.random() > 0.5 ? 1 : -1;
            const directionY = Math.random() > 0.5 ? 1 : -1;
            
            ball_speed_x = INITIAL_BALL_SPEED_X * directionX;
            ball_speed_y = INITIAL_BALL_SPEED_Y * directionY;
        }
        
        function resetGame() {
            resetBall();
            score_left = 0;
            score_right = 0;
            scoreElement.textContent = `${score_left} - ${score_right}`;
            frameCount = 0;
            errorAccumulation1 = 0;
            errorAccumulation2 = 0;
            smoothedErrorOffset1 = 0;
            smoothedErrorOffset2 = 0;
            targetPaddle1Y = 0;
            targetPaddle2Y = 0;
            
            // Randomize colors
            ballColor = getRandomColor();
            paddleColor = getRandomColor();
            boundaryColor = getRandomColor();
            
            ball.material.color.copy(ballColor);
            ball.material.emissive.copy(ballColor);
            paddle1.material.color.copy(paddleColor);
            paddle2.material.color.copy(paddleColor);
            topBoundary.material.color.copy(boundaryColor);
            bottomBoundary.material.color.copy(boundaryColor);
            
            // Update button color to match paddle color
            const buttonRGB = paddleColor.clone().multiplyScalar(255);
            document.getElementById('playAgain').style.background = 
                `linear-gradient(145deg, 
                rgb(${Math.min(255, buttonRGB.r + 30)}, ${Math.min(255, buttonRGB.g + 30)}, ${Math.min(255, buttonRGB.b + 30)}), 
                rgb(${buttonRGB.r}, ${buttonRGB.g}, ${buttonRGB.b}))`;
            
            winMessageElement.style.display = 'none';
            gameActive = true;
        }
        
        function flashScreen() {
            const originalColor = scene.background.clone();
            scene.background = new THREE.Color(Math.random(), Math.random(), Math.random());
            
            setTimeout(() => {
                scene.background = originalColor;
            }, 100);
        }
        
        function endGame(message) {
            winTextElement.textContent = message;
            winMessageElement.style.display = 'block';
            gameActive = false;
        }
        
        function createParticleExplosion(x, y, z, count) {
            const particleGeometry = new THREE.SphereGeometry(2, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: getRandomColor(),
                transparent: true,
                opacity: 1
            });
            
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
                particle.position.set(x, y, z);
                
                particle.velocity = {
                    x: (Math.random() - 0.5) * 10,
                    y: (Math.random() - 0.5) * 10,
                    z: (Math.random() - 0.5) * 10
                };
                
                particle.life = 30; // Frames the particle will live
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.position.x += particle.velocity.x * deltaTime * 0.5;
                particle.position.y += particle.velocity.y * deltaTime * 0.5;
                particle.position.z += particle.velocity.z * deltaTime * 0.5;
                
                particle.life -= deltaTime;
                particle.material.opacity = particle.life / 30;
                
                if (particle.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }
        
        function playSound(frequency, duration) {
            if (!audioEnabled) return; // Don't play sound if audio is disabled
            
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                // Silently fail if audio context isn't available
                console.log("Audio not available", e);
            }
        }
        
        // Initialize and start the game
        initScene();
        requestAnimationFrame(updateGame);
    </script>
</body>
</html>
